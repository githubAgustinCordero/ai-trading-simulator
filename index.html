<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>AI Trading Simulator - Competencia $10,000</title>
    <style>
        :root {
            /* Tema Oscuro (por defecto) */
            --bg-primary: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --bg-card: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-muted: rgba(255, 255, 255, 0.5);
            --border-color: rgba(255, 255, 255, 0.2);
            --positive-color: #4CAF50;
            --negative-color: #f44336;
            --accent-color: #60a5fa;
            --warning-color: #ff9800;
            --log-bg: rgba(0, 0, 0, 0.3);
            --backdrop-blur: blur(15px);
        }

        [data-theme="light"] {
            /* Tema Claro */
            --bg-primary: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            --bg-card: rgba(255, 255, 255, 0.8);
            --text-primary: #1a1a1a;
            --text-secondary: #424242;
            --text-muted: #757575;
            --border-color: rgba(0, 0, 0, 0.1);
            --positive-color: #2e7d32;
            --negative-color: #d32f2f;
            --accent-color: #1976d2;
            --warning-color: #f57c00;
            --log-bg: rgba(248, 249, 250, 0.9);
            --backdrop-blur: blur(10px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            background: var(--bg-card);
            backdrop-filter: var(--backdrop-blur);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, var(--accent-color), var(--positive-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        [data-theme="light"] h1 {
            background: linear-gradient(45deg, #1976d2, #2e7d32);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 1.2em;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            backdrop-filter: var(--backdrop-blur);
            border: 1px solid var(--border-color);
        }

        .btn-start {
            background: linear-gradient(45deg, var(--positive-color), #45a049);
            color: white;
        }

        .btn-stop {
            background: linear-gradient(45deg, var(--negative-color), #d32f2f);
            color: white;
        }

        .btn-reset {
            background: linear-gradient(45deg, var(--warning-color), #f57c00);
            color: white;
        }

        .btn-theme {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 2px solid var(--accent-color);
        }

        .btn-clear {
            padding: 8px 16px;
            background: var(--bg-card);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn-clear:hover {
            background: var(--negative-color);
            color: white;
        }

        /* Estilos para botones deshabilitados */
        .btn-disabled {
            background: rgba(255, 255, 255, 0.1) !important;
            color: rgba(255, 255, 255, 0.5) !important;
            cursor: not-allowed !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
        }

        .btn-disabled:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            transform: none !important;
        }

        .btn:disabled {
            background: rgba(255, 255, 255, 0.1) !important;
            color: rgba(255, 255, 255, 0.5) !important;
            cursor: not-allowed !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
        }

        .btn:disabled:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            transform: none !important;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        /* Asegurar ancho consistente de tarjetas */
        .dashboard .card {
            width: 100%;
            max-width: none;
            box-sizing: border-box;
        }

        .card {
            background: var(--bg-card);
            backdrop-filter: var(--backdrop-blur);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }

        .card h3 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .log-section {
            grid-column: 1 / -1;
            min-height: 400px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric-label {
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .metric-value {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 1.1em;
        }

        .positive {
            color: var(--positive-color);
        }

        .negative {
            color: var(--negative-color);
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: rgba(76, 175, 80, 0.2);
            color: var(--positive-color);
            border: 1px solid var(--positive-color);
        }

        .status-inactive {
            background: rgba(244, 67, 54, 0.2);
            color: var(--negative-color);
            border: 1px solid var(--negative-color);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #81C784);
            transition: width 0.3s ease;
        }

        .trades-section {
            grid-column: 1 / -1;
        }

        /* Hacer que la secci√≥n de posiciones ocupue todo el ancho */
        .positions-section {
            grid-column: 1 / -1;
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            min-width: 800px; /* Asegurar ancho m√≠nimo para todas las columnas */
        }

        .trades-table th,
        .trades-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .trades-table th {
            background: var(--bg-card);
            font-weight: 600;
            color: var(--text-primary);
        }

        .trade-buy {
            color: #4CAF50;
            font-weight: 600;
        }

        .trade-sell {
            color: #f44336;
            font-weight: 600;
        }

        .trade-reason {
            font-size: 0.85em;
            color: var(--text-muted);
            font-style: italic;
        }

        .trades-table .positive {
            color: var(--positive-color);
            font-weight: 600;
        }

        .trades-table .negative {
            color: var(--negative-color);
            font-weight: 600;
        }

        .chart-container {
            height: 300px;
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            position: relative;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100px;
            color: rgba(255, 255, 255, 0.7);
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid;
        }

        .alert-success {
            background: rgba(76, 175, 80, 0.1);
            border-left-color: #4CAF50;
            color: #4CAF50;
        }

        .alert-warning {
            background: rgba(255, 152, 0, 0.1);
            border-left-color: #ff9800;
            color: #ff9800;
        }

        .alert-error {
            background: rgba(244, 67, 54, 0.1);
            border-left-color: #f44336;
            color: #f44336;
        }

        .log-container {
            height: 200px;
            overflow-y: auto;
            background: var(--log-bg);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .log-container-expanded {
            height: 350px;
            overflow-y: auto;
            background: var(--log-bg);
            border-radius: 12px;
            padding: 20px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
            font-size: 0.9em;
            border: 1px solid var(--border-color);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid var(--border-color);
            word-wrap: break-word;
            line-height: 1.4;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-timestamp {
            color: var(--text-muted);
            margin-right: 12px;
            font-weight: 500;
            min-width: 70px;
            display: inline-block;
        }

        .log-icon {
            margin-right: 8px;
            font-size: 0.9em;
        }

        .log-message {
            color: var(--text-primary);
        }

        .log-success .log-message {
            color: var(--positive-color);
        }

        .log-warning .log-message {
            color: var(--warning-color);
        }

        .log-error .log-message {
            color: var(--negative-color);
        }

        .log-trade .log-message {
            color: var(--accent-color);
            font-weight: 600;
        }

        .log-historical {
            opacity: 0.8;
            background: rgba(255, 255, 255, 0.02);
        }

        .log-historical .log-timestamp {
            color: var(--text-muted);
            font-weight: 400;
        }

        @media (max-width: 1200px) {
            .dashboard {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 900px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .dashboard .card {
                width: 100%;
                min-width: 0;
                max-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .controls {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            .controls .btn {
                width: 200px;
                text-align: center;
            }

            .dashboard {
                grid-template-columns: 1fr;
                gap: 15px;
                width: 100%;
            }

            .dashboard .card {
                min-height: 180px;
                padding: 20px;
                width: 100%;
                min-width: 0;
                max-width: 100%;
                box-sizing: border-box;
            }

            .trades-table {
                font-size: 0.75em;
                min-width: 600px; /* Reducir en m√≥viles pero mantener legible */
            }
            
            .trades-table th,
            .trades-table td {
                padding: 8px 6px; /* Reducir padding en m√≥viles */
            }
            
            .trade-reason {
                display: none; /* Ocultar razones en m√≥viles para ahorrar espacio */
            }

            .log-container-expanded {
                height: 300px;
                padding: 15px;
                font-size: 0.8em;
            }

            .log-timestamp {
                min-width: 60px;
                font-size: 0.8em;
            }
        }

        @media (max-width: 480px) {
            .dashboard {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .card {
                padding: 15px;
                margin: 0;
            }

            .card h3 {
                font-size: 1.1em;
            }

            .value {
                font-size: 1.4em;
            }
        }

        /* Secci√≥n Educativa */
        .info-section {
            margin-bottom: 30px;
            background: var(--bg-card);
            border-radius: 15px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .info-toggle {
            width: 100%;
            background: transparent;
            border: none;
            padding: 20px 25px;
            color: var(--text-primary);
            font-size: 1.2em;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
        }

        .info-toggle:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .info-content {
            display: none;
            padding: 0 25px 25px 25px;
            border-top: 1px solid var(--border-color);
        }

        .info-content.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-card h4 {
            color: var(--accent-color);
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-card p {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .info-card ul {
            color: var(--text-secondary);
            margin-left: 20px;
            line-height: 1.6;
        }

        .info-card li {
            margin-bottom: 8px;
        }

        .info-card strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        .algorithm-steps {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .step {
            background: rgba(74, 144, 226, 0.1);
            padding: 12px 15px;
            border-radius: 8px;
            border-left: 3px solid var(--accent-color);
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .metrics-explanation {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .metric-item {
            background: rgba(76, 175, 80, 0.1);
            padding: 12px 15px;
            border-radius: 8px;
            border-left: 3px solid var(--positive-color);
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .simulation-info {
            background: rgba(255, 193, 7, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #FFC107;
        }

        .simulation-info p {
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 10px;
        }

        .simulation-info ul {
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .info-grid {
                grid-template-columns: 1fr;
            }

            .info-toggle {
                padding: 15px 20px;
                font-size: 1.1em;
            }

            .info-content {
                padding: 0 20px 20px 20px;
            }

            .info-card {
                padding: 15px;
            }
        }

        /* Tooltips para m√©tricas */
        .metric-tooltip {
            position: relative;
            cursor: help;
        }

        .metric-tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-text {
            visibility: hidden;
            width: 300px;
            background-color: rgba(30, 30, 50, 0.95);
            backdrop-filter: blur(10px);
            color: #ffffff;
            text-align: left;
            border-radius: 8px;
            padding: 12px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            font-size: 0.9em;
            line-height: 1.4;
        }

        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(30, 30, 50, 0.95) transparent transparent transparent;
        }

        /* Tooltips para tema claro */
        [data-theme="light"] .tooltip-text {
            background-color: rgba(255, 255, 255, 0.95);
            color: #1a1a1a;
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }

        [data-theme="light"] .tooltip-text::after {
            border-color: rgba(255, 255, 255, 0.95) transparent transparent transparent;
        }

        /* Selector de estrategias */
        .strategy-selector {
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .strategy-selector h4 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .strategy-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .strategy-option {
            flex: 1;
            min-width: 200px;
            max-width: 250px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .strategy-option:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent-color);
        }

        .strategy-option.active {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        .strategy-title {
            font-weight: 600;
            font-size: 0.95em;
            margin-bottom: 5px;
        }

        .strategy-description {
            font-size: 0.8em;
            color: var(--text-secondary);
            line-height: 1.3;
        }

        .strategy-option.active .strategy-description {
            color: rgba(255, 255, 255, 0.9);
        }

        /* Force visibility of critical controls */
        #stopLossInput, #setStopLossBtn, #stochSelector, #setStochBtn {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
            position: relative !important;
            z-index: 1000 !important;
        }

        @media (max-width: 768px) {
            .tooltip-text {
                width: 250px;
                margin-left: -125px;
            }
            
            .strategy-options {
                flex-direction: column;
                gap: 10px;
            }
            
            .strategy-option {
                min-width: auto;
                max-width: none;
            }
        }

        /* Estilos para el gr√°fico de Estoc√°stico */
        .stochastic-chart-container {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: var(--backdrop-blur);
            grid-column: 1 / -1;
            transition: all 0.3s ease;
        }

        .stochastic-chart-container.collapsed {
            grid-column: auto;
        }

        .stochastic-chart-container h3 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .stochastic-chart-container h3::after {
            content: '‚¨á';
            font-size: 0.9em;
            transition: transform 0.3s ease;
        }

        .stochastic-chart-container.collapsed h3::after {
            transform: rotate(-90deg);
        }

        .stochastic-chart-wrapper {
            position: relative;
            height: 300px;
            width: 100%;
            overflow: hidden;
            max-height: 300px;
            transition: max-height 0.3s ease;
        }

        .stochastic-chart-container.collapsed .stochastic-chart-wrapper {
            max-height: 0;
            display: none;
        }

        .stochastic-chart-wrapper canvas {
            max-height: 300px;
        }

        @media (max-width: 768px) {
            .stochastic-chart-container {
                grid-column: auto;
            }

            .stochastic-chart-container.collapsed {
                grid-column: auto;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>ü§ñ AI Trading Simulator</h1>
            <p class="subtitle">Competencia de $10,000 - Trading Autom√°tico con IA</p>
            <div class="controls">
                <button id="startBot" class="btn btn-start">‚ñ∂Ô∏è Iniciar Bot</button>
                <button id="stopBot" class="btn btn-stop">‚èπÔ∏è Detener Bot</button>
                <button id="resetBot" class="btn btn-reset">üîÑ Reiniciar</button>
                    <button id="forceSyncBtn" class="btn-clear">üîÅ Forzar Sync</button>
                <div style="display:flex; align-items:center; gap:8px;">
                    <label for="stopLossInput" style="color:var(--text-secondary); font-weight:600;">Stop-loss $</label>
                    <input id="stopLossInput" type="number" step="1" min="0" value="100" style="width:110px; padding:8px; border-radius:8px; border:1px solid var(--border-color); background:transparent; color:var(--text-primary);">
                    <button id="setStopLossBtn" class="btn-clear">üíæ Guardar</button>
                </div>
                <button id="themeToggle" class="btn btn-theme">üåô Modo Oscuro</button>
            </div>
        </header>

        <div id="alerts"></div>

        <!-- Selector de Estrategias -->
        <div class="strategy-selector">
            <h4>üéØ Estrategia de Trading</h4>
            <div class="strategy-options">
                <div class="strategy-option active" data-strategy="maxi1">
                    <div class="strategy-title">‚ôæÔ∏è MAXI1 (Long / Short)</div>
                    <div class="strategy-description">Posici√≥n perpetua LONG o SHORT; cambia seg√∫n Estoc√°stico 15m (sin SL/TP)</div>
                </div>
            </div>
            <div style="margin-top:12px; display:flex; justify-content:center; gap:10px; align-items:center;">
                <label for="stochSelector" style="color:var(--text-secondary); font-weight:600;">Estoc√°stico:</label>
                <select id="stochSelector" style="padding:8px 10px; border-radius:8px; border:1px solid var(--border-color); background:transparent; color:var(--text-primary);">
                    <option value="5m">5 minutos</option>
                    <option value="15m">15 minutos</option>
                    <option value="30m">30 minutos</option>
                </select>
                <button id="setStochBtn" class="btn-clear">üíæ Guardar</button>
            </div>
        </div>

        <!-- Secci√≥n Educativa -->
        <div class="info-section">
            <button class="info-toggle" onclick="toggleInfoSection()">
                üìö ¬øC√≥mo funciona el Bot de Trading? <span id="info-arrow">‚ñº</span>
            </button>
            
            <div id="info-content" class="info-content">
                <div class="info-grid">
                    <div class="info-card">
                        <h4>ü§ñ ¬øQu√© hace el Bot?</h4>
                        <p>El bot es un <strong>trader autom√°tico con inteligencia artificial</strong> que:</p>
                        <ul>
                            <li><strong>Analiza el mercado</strong> cada 30 segundos</li>
                            <li><strong>Calcula 5 indicadores t√©cnicos</strong> diferentes</li>
                            <li><strong>Toma decisiones</strong> de compra/venta autom√°ticamente</li>
                            <li><strong>Gestiona el riesgo</strong> con stop-loss y take-profit</li>
                            <li><strong>Opera 24/7</strong> sin intervenci√≥n humana</li>
                        </ul>
                    </div>

                    <div class="info-card">
                        <h4>üß† ¬øC√≥mo toma decisiones?</h4>
                        <p>El algoritmo de IA eval√∫a <strong>m√∫ltiples se√±ales t√©cnicas</strong>:</p>
                        <ul>
                            <li><strong>RSI (√çndice de Fuerza Relativa)</strong>: Detecta si Bitcoin est√° "sobrecomprado" (>70) o "sobrevendido" (<30)</li>
                            <li><strong>MACD</strong>: Identifica cambios de tendencia y momentum</li>
                            <li><strong>Medias M√≥viles (SMA/EMA)</strong>: Determina la direcci√≥n general del mercado</li>
                            <li><strong>Bandas de Bollinger</strong>: Eval√∫a volatilidad y puntos de entrada</li>
                            <li><strong>Volumen de mercado</strong>: Confirma la fuerza de los movimientos</li>
                        </ul>
                    </div>

                    <div class="info-card">
                        <h4>‚öôÔ∏è Algoritmo de Trading</h4>
                        <p>El bot ejecuta esta l√≥gica <strong>autom√°ticamente cada 30 segundos</strong>:</p>
                        <div class="algorithm-steps">
                            <div class="step">1Ô∏è‚É£ <strong>Recopilar datos</strong>: Obtiene precio actual y hist√≥rico de Bitcoin</div>
                            <div class="step">2Ô∏è‚É£ <strong>Calcular indicadores</strong>: Procesa los 5 indicadores t√©cnicos</div>
                            <div class="step">3Ô∏è‚É£ <strong>Evaluar se√±ales</strong>: IA analiza si es momento de comprar/vender</div>
                            <div class="step">4Ô∏è‚É£ <strong>Gestionar riesgo</strong>: Verifica l√≠mites de p√©rdida y ganancia</div>
                            <div class="step">5Ô∏è‚É£ <strong>Ejecutar operaci√≥n</strong>: Compra o vende si se cumplen las condiciones</div>
                        </div>
                    </div>

                    <div class="info-card">
                        <h4>üìä Explicaci√≥n de M√©tricas</h4>
                        <div class="metrics-explanation">
                            <div class="metric-item">
                                <strong>üí∞ Balance USD:</strong> Dinero disponible en d√≥lares para comprar Bitcoin
                            </div>
                            <div class="metric-item">
                                <strong>‚Çø Bitcoin (BTC):</strong> Cantidad de Bitcoin que posee el bot actualmente
                            </div>
                            <div class="metric-item">
                                <strong>üìà Rendimiento:</strong> Ganancia o p√©rdida total en porcentaje desde el inicio
                            </div>
                            <div class="metric-item">
                                <strong>üìâ Max Drawdown:</strong> La mayor p√©rdida temporal que ha tenido el bot (importante para medir riesgo)
                            </div>
                            <div class="metric-item">
                                <strong>‚ö° Sharpe Ratio:</strong> Mide la eficiencia del bot (rendimiento ajustado por riesgo). >1 es bueno
                            </div>
                            <div class="metric-item">
                                <strong>üéØ Win Rate:</strong> Porcentaje de operaciones ganadoras vs perdedoras
                            </div>
                            <div class="metric-item">
                                <strong>üíé Confianza:</strong> Nivel de certeza del bot en cada operaci√≥n (0-100%)
                            </div>
                        </div>
                    </div>

                    <div class="info-card">
                        <h4>üõ°Ô∏è Gesti√≥n de Riesgo</h4>
                        <p>El bot tiene <strong>m√∫ltiples protecciones autom√°ticas</strong>:</p>
                        <ul>
                            <li><strong>Stop Loss (5%)</strong>: Vende autom√°ticamente si pierde m√°s del 5% en una operaci√≥n</li>
                            <li><strong>Take Profit (10%)</strong>: Toma ganancias autom√°ticamente al 10% de beneficio</li>
                            <li><strong>Tama√±o de posici√≥n</strong>: Nunca invierte m√°s del 80% del capital disponible</li>
                            <li><strong>Cooldown</strong>: Espera 5 minutos entre operaciones para evitar overtrading</li>
                            <li><strong>L√≠mite de p√©rdidas consecutivas</strong>: Se pausa tras 3 p√©rdidas seguidas</li>
                        </ul>
                    </div>

                    <div class="info-card">
                        <h4>üéÆ ¬øEs real el dinero?</h4>
                        <div class="simulation-info">
                            <p><strong>üéØ NO, es una simulaci√≥n educativa</strong></p>
                            <ul>
                                <li>üí∞ Los $10,000 son <strong>virtuales</strong></li>
                                <li>üìä Los precios de Bitcoin son <strong>reales</strong> (API de CoinGecko)</li>
                                <li>ü§ñ El bot ejecuta <strong>operaciones simuladas</strong></li>
                                <li>üìà Las ganancias/p√©rdidas son <strong>te√≥ricas</strong></li>
                                <li>üéì Perfecto para <strong>aprender trading</strong> sin riesgo</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="dashboard">
            <!-- Portfolio Overview -->
            <div class="card">
                <h3>üíº Portafolio</h3>
                <div class="metric">
                    <span class="metric-label">Valor Total</span>
                    <span class="metric-value" id="totalValue">$10,000.00</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Invertido</span>
                    <span class="metric-value" id="investedTotal">$0.00</span>
                </div>
                <div class="metric">
                    <span class="metric-label">No invertido</span>
                    <span class="metric-value" id="uninvestedTotal">$0.00</span>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">Rendimiento</span>
                    <span class="metric-value" id="totalReturn">0.00%</span>
                    <div class="tooltip-text">
                        <strong>üìà Rendimiento Total</strong><br>
                        Ganancia o p√©rdida acumulada desde el inicio de la competencia. Positivo = ganancia, negativo = p√©rdida. Se calcula como: (Valor Actual - $10,000) / $10,000 √ó 100
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="returnProgress" style="width: 50%"></div>
                </div>
            </div>

            <!-- Market Data -->
            <div class="card">
                <h3>üìà Datos de Mercado</h3>
                <div class="metric">
                    <span class="metric-label">Precio BTC</span>
                    <span class="metric-value" id="btcPrice">$0.00</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Cambio 24h</span>
                    <span class="metric-value" id="priceChange">0.00%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">√öltima Actualizaci√≥n</span>
                    <span class="metric-value" id="lastUpdate">-</span>
                </div>
            </div>

            <!-- AI Analysis -->
            <div class="card">
                <h3>üß† An√°lisis de IA</h3>
                <div class="metric">
                    <span class="metric-label">Se√±al Actual</span>
                    <span class="metric-value" id="currentSignal">HOLD</span>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">Confianza</span>
                    <span class="metric-value" id="confidence">0%</span>
                    <div class="tooltip-text">
                        <strong>üíé Nivel de Confianza</strong><br>
                        Porcentaje de certeza del bot en su decisi√≥n actual. >70% = Alta confianza, 40-70% = Confianza media, <40% = Baja confianza. El bot solo opera con confianza >40%.
                    </div>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">RSI</span>
                    <span class="metric-value" id="rsiValue">-</span>
                    <div class="tooltip-text">
                        <strong>üìä RSI (√çndice de Fuerza Relativa)</strong><br>
                        Mide si Bitcoin est√° "sobrecomprado" o "sobrevendido". >70 = Sobrecomprado (posible venta), <30 = Sobrevendido (posible compra), 30-70 = Rango normal.
                    </div>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">SMA 20/50</span>
                    <span class="metric-value" id="smaValues">- / -</span>
                    <div class="tooltip-text">
                        <strong>üìà Medias M√≥viles Simples</strong><br>
                        SMA 20 = Promedio de precio de √∫ltimos 20 per√≠odos, SMA 50 = √∫ltimos 50. Si SMA 20 > SMA 50 = tendencia alcista, si SMA 20 < SMA 50 = tendencia bajista.
                    </div>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">Estoc√°stico 15m</span>
                    <span class="metric-value" id="stoch15mValue">-</span>
                    <div class="tooltip-text">
                        <strong>üìä Estoc√°stico 15 minutos</strong><br>
                        K/D = Valor actual / Media m√≥vil. >80 = Sobrecomprado (posible venta), <20 = Sobrevendido (posible compra). Estrategia 90-9 usa este timeframe.
                    </div>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">Estoc√°stico 30m</span>
                    <span class="metric-value" id="stoch30mValue">-</span>
                    <div class="tooltip-text">
                        <strong>üìä Estoc√°stico 30 minutos</strong><br>
                        K/D = Valor actual / Media m√≥vil. >80 = Sobrecomprado, <20 = Sobrevendido. Cruce K sobre D = se√±al alcista.
                    </div>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">Estoc√°stico 1h</span>
                    <span class="metric-value" id="stoch1hValue">-</span>
                    <div class="tooltip-text">
                        <strong>üìä Estoc√°stico 1 hora</strong><br>
                        K/D = Valor actual / Media m√≥vil. >80 = Sobrecomprado, <20 = Sobrevendido. √ötil para tendencias de largo plazo.
                    </div>
                </div>
            </div>

            <!-- Trading Stats -->
            <div class="card">
                <h3>üìä Estad√≠sticas</h3>
                <div class="metric">
                    <span class="metric-label">Total Operaciones</span>
                    <span class="metric-value" id="totalTrades">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Operaciones Ganadoras</span>
                    <span class="metric-value" id="winningTrades">0</span>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">Tasa de √âxito</span>
                    <span class="metric-value" id="winRate">0.00%</span>
                    <div class="tooltip-text">
                        <strong>üéØ Win Rate (Tasa de √âxito)</strong><br>
                        Porcentaje de operaciones ganadoras vs perdedoras. 60% = Bueno, 70%+ = Excelente. Se calcula como: (Operaciones Ganadoras / Total Operaciones) √ó 100
                    </div>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">Max Drawdown</span>
                    <span class="metric-value" id="maxDrawdown">0.00%</span>
                    <div class="tooltip-text">
                        <strong>üìâ M√°ximo Drawdown</strong><br>
                        La mayor p√©rdida temporal desde el pico m√°s alto. Es crucial para medir el riesgo. <5% = Bajo riesgo, 5-15% = Moderado, >15% = Alto riesgo. Indica la peor racha de p√©rdidas.
                    </div>
                </div>
                <div class="metric">
                    <span class="metric-label">Ganancias Brutas</span>
                    <span class="metric-value" id="grossWins">$0.00</span>
                </div>
                <div class="metric">
                    <span class="metric-label">P√©rdidas Brutas</span>
                    <span class="metric-value" id="grossLosses">$0.00</span>
                </div>
                <div class="metric metric-tooltip">
                    <span class="metric-label">Profit Factor</span>
                    <span class="metric-value" id="profitFactor">-</span>
                    <div class="tooltip-text">
                        <strong>üìà Profit Factor</strong><br>
                        Relaci√≥n entre ganancias brutas y p√©rdidas brutas. >1 = rentable, cuanto mayor mejor.
                    </div>
                </div>
            </div>

            <!-- Recent Trades -->
            <div class="card trades-section">
                <h3>üíπ Operaciones Recientes</h3>
                <div style="overflow-x: auto;">
                    <table class="trades-table">
                        <thead>
                            <tr>
                                <th>Fecha Apertura</th>
                                <th>Fecha Cierre</th>
                                <th>Tipo</th>
                                <th>Lado</th>
                                <th>Cantidad BTC</th>
                                <th>Precio Entrada</th>
                                <th>Precio Salida</th>
                                <th>USD</th>
                                <th>Ganancia/P√©rdida</th>
                                <th>ROI %</th>
                                <th>Raz√≥n</th>
                            </tr>
                        </thead>
                        <tbody id="tradesTable">
                            <tr>
                                <td colspan="10" style="text-align: center; color: rgba(255,255,255,0.5);">
                                    No hay operaciones a√∫n
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Open Positions -->
            <div class="card positions-section">
                <h3>üìÇ Posiciones Abiertas</h3>
                <div style="overflow-x: auto;">
                    <table class="trades-table">
                        <thead>
                            <tr>
                                <th>Entrada</th>
                                <th>Lado</th>
                                <th>Cantidad BTC</th>
                                <th>Precio Entrada</th>
                                <th>Precio Actual</th>
                                <th>Valor/Exposici√≥n USD</th>
                                <th>PNL no realizado</th>
                                <th>PNL %</th>
                            </tr>
                        </thead>
                        <tbody id="positionsTable">
                            <tr>
                                <td colspan="8" style="text-align: center; color: rgba(255,255,255,0.5);">
                                    Sin posiciones abiertas
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Positions History -->
            <div class="card" style="grid-column: 1 / -1;">
                <h3>üóÇÔ∏è Hist√≥rico de Posiciones (Open / Close)</h3>
                <div style="overflow-x: auto;">
                    <table class="trades-table">
                        <thead>
                            <tr>
                                <th>Position ID</th>
                                <th>Lado</th>
                                <th>Fecha Apertura</th>
                                <th>Fecha Cierre</th>
                                <th>USD Entrada</th>
                                <th>USD Salida</th>
                                <th>PnL</th>
                            </tr>
                        </thead>
                        <tbody id="positionsHistoryTable">
                            <tr>
                                <td colspan="7" style="text-align: center; color: rgba(255,255,255,0.5);">
                                    No hay historial de posiciones
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Activity Log - Expandido -->
            <div class="card log-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3>üìã Log de Actividad</h3>
                    <button id="clearLog" class="btn-clear" onclick="clearActivityLog()">üóëÔ∏è Limpiar</button>
                </div>
                <div class="log-container-expanded" id="activityLog">
                    <div class="loading">
                        <div class="spinner"></div>
                        Esperando actividad del bot...
                    </div>
                </div>
            </div>

            <!-- Gr√°fico del Estoc√°stico 15m -->
            <div class="stochastic-chart-container" id="stochasticChartContainer">
                <h3 onclick="event.currentTarget.parentElement.classList.toggle('collapsed')">üìà Estoc√°stico 15m (K & D)</h3>
                <div class="stochastic-chart-wrapper">
                    <canvas id="stochasticChart15m"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        class TradingDashboard {
            constructor() {
                this.ws = null;
                this.isConnected = false;
                this.data = {
                    portfolio: {},
                    market: {},
                    bot: {},
                    trades: []
                };
                
                // Variables para el gr√°fico del estoc√°stico
                this.stochChart15m = null;
                this.stochHistory = {
                    timestamps: [],
                    k15m: [],
                    d15m: []
                };
                this.maxHistoryPoints = 50; // Mostrar √∫ltimos 50 puntos
                
                this.initializeChart();
                this.initializeWebSocket();
                this.setupEventListeners();
                // Cargar lista de estrategias permitidas desde el servidor para evitar desincronizaci√≥n
                this.loadAllowedStrategies();
                this.setupChartToggle();
                this.startPeriodicUpdates();
                // Debounce helpers to avoid UI flicker when server broadcasts very frequently
                this._positionsUpdateTimer = null;
                this._lastOpenPositionsHash = null;
                this._positionsDebounceMs = 1200; // milliseconds to debounce position renders
            }

            async loadAllowedStrategies() {
                try {
                    const resp = await fetch('/ai-trading-simulator-old/api/bot/strategies');
                    if (!resp.ok) throw new Error('No response');
                    const json = await resp.json();
                    if (json && json.success) {
                        // Simplified: only MAXI1 supported
                        this.allowedStrategies = Array.isArray(json.strategies) ? json.strategies : ['maxi1'];
                        this.strategyNames = json.names || {
                            'maximize-usd': 'Maximizar USD',
                            'maximize-btc': 'Maximizar BTC',
                            'julio2': 'Julio2.0 (Stoch 34,3,3)',
                            'estocastico909': '90-9 Estocastico',
                            'maxi1': 'MAXI1 (Long/Short)'
                        };
                        console.log('‚úÖ Estrategias cargadas desde servidor:', this.allowedStrategies);
                        return;
                    }
                } catch (err) {
                    console.warn('‚ö†Ô∏è No se pudo cargar la lista de estrategias desde el servidor, usando fallback', err);
                }

                // Fallback por si falla la petici√≥n
                // Simplified: only MAXI1 supported
                this.allowedStrategies = ['maxi1'];
                this.strategyNames = {
                    'maximize-usd': 'Maximizar USD',
                    'maximize-btc': 'Maximizar BTC',
                    'julio2': 'Julio2.0 (Stoch 34,3,3)',
                    'estocastico909': '90-9 Estocastico',
                    'maxi1': 'MAXI1 (Long/Short)'
                };
            }

            initializeChart() {
                console.log('üîß Inicializando gr√°fico estoc√°stico...');

                const ctx = document.getElementById('stochasticChart15m');
                if (!ctx) {
                    console.log('‚ùå No se encontr√≥ el elemento canvas stochasticChart15m');
                    return;
                }

                console.log('‚úÖ Canvas encontrado, creando gr√°fico Chart.js...');

                this.stochChart15m = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'K (15m)',
                                data: [],
                                borderColor: '#60a5fa',
                                backgroundColor: 'rgba(96, 165, 250, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 3,
                                pointHoverRadius: 5,
                                pointBackgroundColor: '#60a5fa'
                            },
                            {
                                label: 'D (15m)',
                                data: [],
                                borderColor: '#fbbf24',
                                backgroundColor: 'rgba(251, 191, 36, 0.1)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 3,
                                pointHoverRadius: 5,
                                pointBackgroundColor: '#fbbf24'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim() || '#ffffff',
                                    usePointStyle: true,
                                    font: { size: 12, weight: 'bold' }
                                }
                            },
                            filler: {
                                propagate: true
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                min: 0,
                                ticks: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim() || 'rgba(255,255,255,0.7)',
                                    callback: function(value) {
                                        if (value === 0 || value === 20 || value === 50 || value === 80 || value === 100) {
                                            return value;
                                        }
                                    }
                                },
                                grid: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim() || 'rgba(255,255,255,0.1)',
                                    drawBorder: true,
                                    lineWidth: (ctx) => {
                                        if (ctx.tick.value === 20 || ctx.tick.value === 80) {
                                            return 2;
                                        }
                                        return 1;
                                    }
                                }
                            },
                            x: {
                                ticks: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim() || 'rgba(255,255,255,0.7)'
                                },
                                grid: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim() || 'rgba(255,255,255,0.1)'
                                }
                            }
                        }
                    },
                    plugins: [
                        {
                            id: 'stochasticZones',
                            afterDatasetsDraw(chart) {
                                const ctx = chart.ctx;
                                const yScale = chart.scales.y;
                                const xScale = chart.scales.x;
                                
                                if (!yScale || !xScale) return;
                                
                                const chartArea = chart.chartArea;
                                const width = chartArea.right - chartArea.left;
                                const height = chartArea.bottom - chartArea.top;
                                
                                // Convertir valores 20 y 80 a coordenadas del canvas
                                const y20 = yScale.getPixelForValue(20);
                                const y80 = yScale.getPixelForValue(80);
                                const y50 = yScale.getPixelForValue(50);
                                
                                // Zona de Sobreventa (0-20) - Rojo suave
                                ctx.fillStyle = 'rgba(239, 68, 68, 0.08)';
                                ctx.fillRect(chartArea.left, chartArea.bottom, width, y20 - chartArea.bottom);
                                
                                // Zona de Sobrecompra (80-100) - Verde suave
                                ctx.fillStyle = 'rgba(34, 197, 94, 0.08)';
                                ctx.fillRect(chartArea.left, chartArea.top, width, y80 - chartArea.top);
                                
                                // L√≠nea en 20 - Roja punteada (limite de sobreventa)
                                ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([5, 5]);
                                ctx.beginPath();
                                ctx.moveTo(chartArea.left, y20);
                                ctx.lineTo(chartArea.right, y20);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // L√≠nea en 50 - Gris neutra
                                ctx.strokeStyle = 'rgba(107, 114, 128, 0.4)';
                                ctx.lineWidth = 1;
                                ctx.setLineDash([3, 3]);
                                ctx.beginPath();
                                ctx.moveTo(chartArea.left, y50);
                                ctx.lineTo(chartArea.right, y50);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // L√≠nea en 80 - Verde punteada (limite de sobrecompra)
                                ctx.strokeStyle = 'rgba(34, 197, 94, 0.6)';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([5, 5]);
                                ctx.beginPath();
                                ctx.moveTo(chartArea.left, y80);
                                ctx.lineTo(chartArea.right, y80);
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // Etiquetas de zonas
                                ctx.font = 'bold 11px system-ui';
                                ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                                ctx.textAlign = 'right';
                                ctx.fillText('SOBREVENTA', chartArea.right - 5, chartArea.bottom + 15);
                                
                                ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
                                ctx.fillText('SOBRECOMPRA', chartArea.right - 5, chartArea.top + 12);
                            }
                        }
                    ]
                });

                console.log('‚úÖ Gr√°fico estoc√°stico inicializado correctamente');
            }

            initializeWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                // Conectar al WebSocket usando la ruta del proyecto
                const wsUrl = `${protocol}//${window.location.host}/ai-trading-simulator-old/`;
                
                console.log('üîå Intentando conectar WebSocket a:', wsUrl);
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        this.showAlert('Conectado al servidor - Cargando historial...', 'success');
                        console.log('WebSocket conectado');
                        
                        // Cargar historial completo al conectarse
                        this.loadCompleteHistory();
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (error) {
                            console.error('Error procesando mensaje:', error);
                        }
                    };

                    this.ws.onclose = () => {
                        this.isConnected = false;
                        this.showAlert('Conexi√≥n perdida. Reintentando...', 'warning');
                        setTimeout(() => this.initializeWebSocket(), 3000);
                    };

                    this.ws.onerror = (error) => {
                        console.error('Error WebSocket:', error);
                        this.showAlert('Error de conexi√≥n', 'error');
                    };
                } catch (error) {
                    console.error('Error inicializando WebSocket:', error);
                    this.fallbackToPolling();
                }
            }

            fallbackToPolling() {
                console.log('Usando polling como fallback');
                this.startPeriodicUpdates();
            }

            handleWebSocketMessage(data) {
                console.log('üì° WebSocket message received:', data.type, data);

                if (data.type === 'update') {
                    console.log('üîÑ Processing update message');

                    // Validar datos antes de aceptarlos
                    // Preferir la nueva estructura `portfolioSummary` que contiene: initialBalance, currentValue, pnl, realizedPnL, unrealizedPnL
                    const portfolio = data.data.portfolio || {};
                    const portfolioSummary = data.data.portfolioSummary || {};

                    // Compatibilidad: aceptar currentValue desde portfolioSummary, o totalValue desde portfolio/stats
                    const totalValue = (typeof portfolioSummary.currentValue === 'number') ? portfolioSummary.currentValue : ((typeof portfolio.totalValue === 'number') ? portfolio.totalValue : (data.data.stats && data.data.stats.totalValue ? data.data.stats.totalValue : 0));
                    const balance = (typeof portfolio.balance === 'number') ? portfolio.balance : (data.data.stats && typeof data.data.stats.balance === 'number' ? data.data.stats.balance : 0);

                    // Validaci√≥n relajada: considerar v√°lido si el valor total del portafolio es razonable
                    const isValidData = (typeof totalValue === 'number' && totalValue >= 1000) || (typeof portfolioSummary.initialBalance === 'number');

                    if (!isValidData) {
                        console.error('üö® WebSocket recibi√≥ datos INV√ÅLIDOS (rejected):', {
                            totalValue: totalValue,
                            balance: balance,
                            btcAmount: portfolio.btcAmount,
                            currentBtcPrice: data.data.market?.price,
                            portfolioSummary: portfolioSummary,
                            fullPortfolio: portfolio,
                            timestamp: new Date().toISOString()
                        });
                        return; // Ignorar datos inv√°lidos
                    }
                    
                    // Log cuando el valor cambia significativamente
                    const currentTotalValue = this.data.portfolio?.totalValue || 0;
                    if (Math.abs(portfolio.totalValue - currentTotalValue) > 100) {
                        console.log('üìä Valor Total cambi√≥ significativamente:', {
                            anterior: currentTotalValue,
                            nuevo: portfolio.totalValue,
                            diferencia: portfolio.totalValue - currentTotalValue,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    // Hacer deep merge de objetos para preservar toda la estructura
                    this.data = {
                        ...this.data,
                        ...data.data,
                        bot: {
                            ...this.data.bot,
                            ...(data.data.bot || {}),
                            signals: {
                                ...this.data.bot?.signals,
                                ...(data.data.bot?.signals || {}),
                                indicators: {
                                    ...this.data.bot?.signals?.indicators,
                                    ...(data.data.bot?.signals?.indicators || {})
                                }
                            }
                        }
                    };

                    console.log('‚úÖ Data merged, calling updateDashboard');
                    this.updateDashboard();
                } else if (data.type === 'trade') {
                    this.addTradeToHistory(data.trade);
                    this.addLogEntry(`Nueva operaci√≥n: ${data.trade.type} ${(data.trade.amount || 0).toFixed(8)} BTC`);
                } else if (data.type === 'log') {
                    this.addLogEntry(data.message, data.level);
                } else {
                    console.log('‚ö†Ô∏è Unknown message type:', data.type);
                }
            }

            setupEventListeners() {
                document.getElementById('startBot').addEventListener('click', () => {
                    this.controlBot('start');
                });

                document.getElementById('stopBot').addEventListener('click', () => {
                    this.controlBot('stop');
                });

                document.getElementById('resetBot').addEventListener('click', () => {
                    if (confirm('¬øEst√°s seguro de que quieres reiniciar el bot? Esto borrar√° todo el historial.')) {
                        this.controlBot('reset');
                    }
                });

                const forceBtn = document.getElementById('forceSyncBtn');
                if (forceBtn) {
                    forceBtn.addEventListener('click', () => {
                        if (confirm('Forzar sincronizaci√≥n con el servidor (rebuild)?')) {
                            this.forceSync();
                        }
                    });
                }

                // Event listeners para selector de estrategias
                document.querySelectorAll('.strategy-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const strategy = option.dataset.strategy || option.getAttribute('data-strategy');
                        this.selectStrategy(strategy);
                    });
                });

                // Stop-loss control
                const stopBtn = document.getElementById('setStopLossBtn');
                const stopInput = document.getElementById('stopLossInput');
                if (stopBtn && stopInput) {
                    stopBtn.addEventListener('click', async () => {
                        const v = Number(stopInput.value);
                        if (!Number.isFinite(v) || v < 0) {
                            this.showAlert('Stop-loss inv√°lido', 'error');
                            return;
                        }
                        try {
                            const resp = await fetch('/ai-trading-simulator-old/api/bot/stoploss', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ stopLossUsd: v }) });
                            const j = await resp.json();
                            if (j && j.success) {
                                this.showAlert(`Stop-loss actualizado a $${Number(v).toFixed(2)}`, 'success');
                            } else {
                                this.showAlert('Error actualizando stop-loss: ' + (j && j.message ? j.message : 'unknown'), 'error');
                            }
                        } catch (err) {
                            console.error('Error guardando stop-loss:', err);
                            this.showAlert('Error guardando stop-loss: ' + (err.message || err), 'error');
                        }
                    });

                    // Load current value initially
                    try { this.fetchStopLoss(); } catch(e){}
                }

                // Stochastic selector control
                const stochSelector = document.getElementById('stochSelector');
                const setStochBtn = document.getElementById('setStochBtn');
                if (stochSelector) {
                    // Load current value
                    try { this.fetchStochPeriod(); } catch(e){}
                    stochSelector.addEventListener('change', (e) => {
                        // enable save button when changed
                        if (setStochBtn) setStochBtn.disabled = false;
                    });
                }
                if (setStochBtn && stochSelector) {
                    setStochBtn.addEventListener('click', async () => {
                        const val = stochSelector.value;
                        try {
                            const resp = await fetch('/ai-trading-simulator-old/api/bot/stoch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ period: val }) });
                            const j = await resp.json();
                            if (j && j.success) {
                                this.showAlert('Estoc√°stico actualizado a ' + val, 'success');
                                if (setStochBtn) setStochBtn.disabled = true;
                                // refresh data
                                try { await this.fetchData(); } catch(e){}
                            } else {
                                this.showAlert('Error guardando estoc√°stico: ' + (j && j.message ? j.message : 'unknown'), 'error');
                            }
                        } catch (err) {
                            console.error('Error guardando estoc√°stico:', err);
                            this.showAlert('Error guardando estoc√°stico: ' + (err.message || err), 'error');
                        }
                    });
                }
            }

            async forceSync() {
                try {
                    const response = await fetch('/ai-trading-simulator-old/api/bot/rebuild', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) });
                    const result = await response.json();
                    if (result && result.success) {
                        this.showAlert('Sincronizaci√≥n forzada: ' + (result.message || 'OK'), 'success');
                        this.addLogEntry('Forzado rebuild ejecutado correctamente', 'success');
                    } else {
                        this.showAlert('Error forzando sincronizaci√≥n: ' + (result && result.message ? result.message : 'unknown'), 'error');
                    }
                } catch (err) {
                    console.error('Error forzando sincronizaci√≥n:', err);
                    this.showAlert('Error al forzar sincronizaci√≥n: ' + (err.message || err), 'error');
                }

                // Siempre intentar recargar datos del servidor despu√©s del rebuild
                try {
                    await this.fetchData();
                } catch (err) {
                    console.warn('fetchData fallo despu√©s de forceSync:', err);
                }
            }

            setupChartToggle() {
                const chartContainer = document.getElementById('stochasticChartContainer');
                if (!chartContainer) return;

                const h3 = chartContainer.querySelector('h3');
                if (h3) {
                    h3.addEventListener('click', (e) => {
                        e.preventDefault();
                        chartContainer.classList.toggle('collapsed');
                        
                        // Trigger chart resize despu√©s de la animaci√≥n
                        setTimeout(() => {
                            if (this.stochChart15m) {
                                this.stochChart15m.resize();
                            }
                        }, 300);
                    });
                }
            }

            selectStrategy(strategy) {
                // Actualizar UI
                document.querySelectorAll('.strategy-option').forEach(option => {
                    option.classList.remove('active');
                });
                const strategySelector = `[data-strategy="${strategy}"]`;
                const activeElement = document.querySelector(strategySelector);
                if (activeElement) {
                    activeElement.classList.add('active');
                }
                
                // Enviar cambio al servidor
                this.updateStrategy(strategy);
            }

            async updateStrategy(strategy) {
                try {
                    // Usar la lista de estrategias cargada desde el servidor (o fallback local)
                    // Simplified: only MAXI1 supported
                    const allowedStrategies = this.allowedStrategies || ['maxi1'];
                    const strategyNames = this.strategyNames || {
                        'maximize-usd': 'Maximizar USD',
                        'maximize-btc': 'Maximizar BTC',
                        'julio2': 'Julio2.0 (Stoch 34,3,3)',
                        'estocastico909': '90-9 Estocastico',
                        'maxi1': 'MAXI1 (Long/Short)'
                    };

                    // Asegurar que sea string, trim y normalizar a min√∫sculas para consistencia
                    const cleanStrategy = String(strategy || '').trim();
                    const normalizedStrategy = cleanStrategy.toLowerCase();

                    if (!allowedStrategies.includes(normalizedStrategy)) {
                        console.error('Frontend: Estrategia no permitida:', normalizedStrategy);
                        this.showAlert('Error: Estrategia no v√°lida', 'error');
                        return;
                    }

                    const response = await fetch('/ai-trading-simulator-old/api/bot/strategy', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        // Enviar siempre la forma normalizada (min√∫sculas)
                        body: JSON.stringify({ strategy: normalizedStrategy })
                    });

                    const result = await response.json();
                    
                    if (result.success) {
                        const name = strategyNames[normalizedStrategy] || normalizedStrategy;
                        this.showAlert(`Estrategia cambiada a: ${name}`, 'success');
                    } else {
                        this.showAlert('Error cambiando estrategia: ' + result.message, 'error');
                    }
                } catch (error) {
                    console.error('Error actualizando estrategia:', error);
                    this.showAlert('Error de conexi√≥n al cambiar estrategia', 'error');
                }
            }

            updateControlButtons(isActive) {
                const startBtn = document.getElementById('startBot');
                const stopBtn = document.getElementById('stopBot');
                const resetBtn = document.getElementById('resetBot');
                
                if (isActive) {
                    // Bot est√° activo
                    startBtn.disabled = true;
                    startBtn.textContent = '‚úÖ Bot Activo';
                    startBtn.title = 'El bot ya est√° funcionando';
                    
                    stopBtn.disabled = false;
                    stopBtn.textContent = '‚èπÔ∏è Detener Bot';
                    stopBtn.title = 'Detener el bot de trading';
                    
                    resetBtn.disabled = false;
                    resetBtn.title = 'Reiniciar bot y borrar historial';
                } else {
                    // Bot est√° inactivo
                    startBtn.disabled = false;
                    startBtn.textContent = '‚ñ∂Ô∏è Iniciar Bot';
                    startBtn.title = 'Iniciar el bot de trading autom√°tico';
                    
                    stopBtn.disabled = true;
                    stopBtn.textContent = '‚è∏Ô∏è Bot Detenido';
                    stopBtn.title = 'El bot no est√° funcionando';
                    
                    resetBtn.disabled = false;
                    resetBtn.title = 'Reiniciar bot y borrar historial';
                }
                
                // Actualizar clases CSS para el estado visual
                this.updateButtonStyles(isActive);
            }

            updateButtonStyles(isActive) {
                const startBtn = document.getElementById('startBot');
                const stopBtn = document.getElementById('stopBot');
                
                if (isActive) {
                    startBtn.classList.remove('btn-start');
                    startBtn.classList.add('btn-disabled');
                    stopBtn.classList.remove('btn-disabled');
                    stopBtn.classList.add('btn-stop');
                } else {
                    startBtn.classList.remove('btn-disabled');
                    startBtn.classList.add('btn-start');
                    stopBtn.classList.remove('btn-stop');
                    stopBtn.classList.add('btn-disabled');
                }
            }

            async loadCompleteHistory() {
                try {
                    // Obtener historial completo desde el servidor
                    const response = await fetch('/ai-trading-simulator-old/api/history');
                    if (!response.ok) {
                        throw new Error(`Error del servidor: ${response.status}`);
                    }
                    
                    const history = await response.json();
                    console.log('Historial cargado:', history);
                    
                    // Poblar el historial de trades
                    if (history.trades && history.trades.length > 0) {
                        // Asegurar orden cronol√≥gico ascendente en la carga inicial
                        const orderedTrades = [...history.trades].sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
                        orderedTrades.forEach(trade => {
                            this.addTradeToHistory(trade);
                        });
                    }
                    
                    // Poblar el log de actividad
                    if (history.logs && history.logs.length > 0) {
                        // Mostrar logs hist√≥ricos del m√°s antiguo al m√°s reciente (arriba‚Üíabajo)
                        const orderedLogs = [...history.logs].sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
                        orderedLogs.forEach(log => {
                            this.addLogEntry(log.message, log.level || 'info', log.timestamp);
                        });
                    }
                    
                    // Actualizar estad√≠sticas si est√°n disponibles
                    if (history.stats) {
                        // Las estad√≠sticas se actualizar√°n con el pr√≥ximo mensaje WebSocket
                        console.log('Estad√≠sticas hist√≥ricas disponibles:', history.stats);
                    }
                    
                    this.showAlert('Historial cargado completamente', 'success');
                        // Store positionsHistory for UI
                        this.data = {
                            ...this.data,
                            positionsHistory: history.positionsHistory || []
                        };
                        // Render positions history immediately
                        this.updatePositionsHistory();
                    
                } catch (error) {
                    console.error('Error cargando historial:', error);
                    this.showAlert('Error cargando historial: ' + error.message, 'error');
                }
            }

            async controlBot(action) {
                try {
                    const response = await fetch(`/ai-trading-simulator-old/api/bot/${action}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    const result = await response.json();
                    
                    if (result.success) {
                        this.showAlert(`Bot ${action === 'start' ? 'iniciado' : action === 'stop' ? 'detenido' : 'reiniciado'}`, 'success');
                        this.addLogEntry(`Bot ${action} ejecutado correctamente`);
                        
                        // Si es reset, limpiar logs del frontend tambi√©n
                        if (action === 'reset') {
                            const logContainer = document.getElementById('activityLog');
                            if (logContainer) {
                                logContainer.innerHTML = '<div class="log-entry log-info">üîÑ Sistema reiniciado - Historial limpiado</div>';
                            }
                            // Forzar actualizaci√≥n inmediata de datos despu√©s del reset
                            console.log('üîÑ Reset ejecutado - forzando actualizaci√≥n de datos...');
                            this.data = null; // Limpiar datos actuales para forzar recarga completa
                            await this.fetchData(); // Esperar a que se complete la recarga
                        }
                    } else {
                        this.showAlert(`Error: ${result.message}`, 'error');
                    }
                } catch (error) {
                    console.error(`Error controlando bot (${action}):`, error);
                    this.showAlert(`Error controlando bot: ${error.message}`, 'error');
                }
            }

            async fetchData() {
                try {
                    const response = await fetch('/ai-trading-simulator-old/api/status');
                    const data = await response.json();
                    
                    if (data.success) {
                        // Validaci√≥n relajada: aceptar actualizaciones cuando el totalValue es razonable
                        // Preferir `portfolioSummary.currentValue` si el backend lo provee
                        const portfolio = data.data.portfolio || {};
                        const portfolioSummary = data.data.portfolioSummary || {};
                        const totalValue = (typeof portfolioSummary.currentValue === 'number') ? portfolioSummary.currentValue : ((typeof portfolio.totalValue === 'number') ? portfolio.totalValue : (data.data.stats && data.data.stats.totalValue ? data.data.stats.totalValue : 0));

                        // Nota: en SIMPLE MODE el backend puede reportar balance=0 temporalmente,
                        // por eso no exigimos balance >= 1000 aqu√≠ si el backend env√≠a initialBalance.
                        const isValidData = (typeof totalValue === 'number' && totalValue >= 1000) || (typeof portfolioSummary.initialBalance === 'number');
                        if (!isValidData) {
                            // Si no hay un totalValue razonable, aceptamos la respuesta s√≥lo si
                            // el backend incluye posiciones abiertas expl√≠citas (fallback).
                            const hasPositions = Array.isArray(data.data.positions && data.data.positions.open) && data.data.positions.open.length > 0;
                            if (!hasPositions) {
                                console.error('üö® fetchData recibi√≥ datos INV√ÅLIDOS y sin posiciones abiertas:', { totalValue: totalValue, balance: portfolio.balance, portfolioSummary: portfolioSummary });
                                return; // No actualizar con datos inv√°lidos y sin posiciones
                            }
                        }
                        
                        // Log cuando el valor cambia significativamente
                        const currentTotalValue = this.data.portfolio?.totalValue || 0;
                        if (Math.abs(portfolio.totalValue - currentTotalValue) > 100) {
                            console.log('üìä fetchData: Valor Total cambi√≥ significativamente:', {
                                anterior: currentTotalValue,
                                nuevo: portfolio.totalValue,
                                diferencia: portfolio.totalValue - currentTotalValue,
                                timestamp: new Date().toISOString()
                            });
                        }
                        
                        this.data = data.data;
                        this.updateDashboard();
                    }
                } catch (error) {
                    console.error('Error fetching data:', error);
                }
            }

            async fetchStopLoss() {
                try {
                    const resp = await fetch('/ai-trading-simulator-old/api/bot/stoploss');
                    if (!resp.ok) return;
                    const j = await resp.json();
                    if (j && j.success && typeof j.stopLossUsd !== 'undefined') {
                        const inp = document.getElementById('stopLossInput');
                        if (inp) inp.value = Number(j.stopLossUsd);
                    }
                } catch (e) {
                    console.warn('No se pudo obtener stop-loss desde servidor:', e && e.message ? e.message : e);
                }
            }

            async fetchStochPeriod() {
                try {
                    const resp = await fetch('/ai-trading-simulator-old/api/bot/stoch');
                    if (!resp.ok) return;
                    const j = await resp.json();
                    if (j && j.success && j.stochPeriod) {
                        const sel = document.getElementById('stochSelector');
                        if (sel) {
                            sel.value = j.stochPeriod;
                            const setBtn = document.getElementById('setStochBtn');
                            if (setBtn) setBtn.disabled = true;
                        }
                    }
                } catch (e) {
                    console.warn('No se pudo obtener stochPeriod desde servidor:', e && e.message ? e.message : e);
                }
            }

            updateDashboard() {
                this.updatePortfolio();
                this.updateMarket();
                this.updateBot();
                this.updateStats();
                this.updateTrades();
                this.updatePositions();
                this.updatePositionsHistory();
                this.updateStochasticChart();
            }

            updateStochasticChart() {
                console.log('üîÑ updateStochasticChart() called');

                if (!this.stochChart15m) {
                    console.log('‚ùå stochChart15m no est√° inicializado');
                    return;
                }

                const bot = this.data.bot || {};
                const signals = bot.signals || {};
                const indicators = signals.indicators || {};
                const stoch = indicators.stoch || {};
                const period = (this.data.bot && this.data.bot.stochPeriod) ? this.data.bot.stochPeriod : '15m';
                const stPeriod = stoch[period] || {};

                console.log('üìä Datos estoc√°sticos:', { stoch: stoch, period: period, stPeriod: stPeriod, k: stPeriod.k, d: stPeriod.d });

                if (typeof stPeriod.k === 'number' && typeof stPeriod.d === 'number') {
                    console.log('‚úÖ Datos v√°lidos, actualizando gr√°fico');

                    // Obtener timestamp actual
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

                    // Agregar datos al historial
                    this.stochHistory.timestamps.push(timeStr);
                    this.stochHistory.k15m.push(stPeriod.k);
                    this.stochHistory.d15m.push(stPeriod.d);

                    // Mantener solo los √∫ltimos N puntos
                    if (this.stochHistory.timestamps.length > this.maxHistoryPoints) {
                        this.stochHistory.timestamps.shift();
                        this.stochHistory.k15m.shift();
                        this.stochHistory.d15m.shift();
                    }

                    console.log('üìà Actualizando gr√°fico con:', {
                        timestamps: this.stochHistory.timestamps.length,
                        kValues: this.stochHistory.k15m.slice(-3),
                        dValues: this.stochHistory.d15m.slice(-3)
                    });

                    // Actualizar gr√°fico
                    this.stochChart15m.data.labels = this.stochHistory.timestamps;
                    this.stochChart15m.data.datasets[0].data = this.stochHistory.k15m;
                    this.stochChart15m.data.datasets[1].data = this.stochHistory.d15m;
                    // Update labels to indicate the timeframe
                    this.stochChart15m.data.datasets[0].label = `K (${period})`;
                    this.stochChart15m.data.datasets[1].label = `D (${period})`;
                    this.stochChart15m.update('none'); // 'none' = sin animaci√≥n para que sea m√°s fluido

                    console.log('‚úÖ Gr√°fico actualizado');
                } else {
                    console.log('‚ùå Datos no v√°lidos para actualizar gr√°fico');
                }
            }

            // Funci√≥n de debug para probar el gr√°fico manualmente
            debugUpdateStochastic(k, d) {
                console.log('üîß Debug: Forzando actualizaci√≥n con K=' + k + ', D=' + d);
                // Simular datos
                this.data = {
                    ...this.data,
                    bot: {
                        ...this.data.bot,
                        signals: {
                            ...this.data.bot?.signals,
                            indicators: {
                                ...this.data.bot?.signals?.indicators,
                                stoch: {
                                    '15m': { k: k, d: d, kPrev: k - 5, dPrev: d - 3, crossUp: false, crossDown: false }
                                }
                            }
                        }
                    }
                };
                this.updateStochasticChart();
            }

            updatePortfolio() {
                const portfolio = this.data.portfolio || {};
                const portfolioSummary = this.data.portfolioSummary || {};
                const positions = this.data.positions || {};
                const invested = positions.invested || {};

                // Deterministic display: prefer authoritative definition
                // 1) If backend provides portfolioSummary.currentValue use it
                // 2) Else, if we have balance + unrealizedPnL compute totalValue (most reliable)
                // 3) Else fall back to portfolio.totalValue (legacy)
                // 4) Finally default to initial 10000
                let displayValue;
                if (typeof portfolioSummary.currentValue === 'number') {
                    displayValue = portfolioSummary.currentValue;
                } else if (typeof portfolio.balance === 'number' && typeof portfolioSummary.unrealizedPnL === 'number') {
                    displayValue = Number(portfolio.balance) + Number(portfolioSummary.unrealizedPnL);
                } else if (typeof portfolio.totalValue === 'number') {
                    displayValue = portfolio.totalValue;
                } else if (positions && positions.invested && typeof positions.invested.totalValue === 'number') {
                    // fallback: some broadcasts populated positions.invested.totalValue
                    displayValue = positions.invested.totalValue;
                } else {
                    displayValue = 10000;
                }

                const totalValueEl = document.getElementById('totalValue');
                if (totalValueEl) {
                    totalValueEl.textContent = `$${(displayValue).toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                }

                // Invertido / No invertido
                const investedTotalEl = document.getElementById('investedTotal');
                const uninvestedTotalEl = document.getElementById('uninvestedTotal');

                // Invested: preferir valores expl√≠citos del backend (positions.invested)
                const investedUsd = (typeof invested.totalUsd === 'number') ? invested.totalUsd : ((typeof invested.totalValue === 'number') ? invested.totalValue : 0);
                if (investedTotalEl) investedTotalEl.textContent = `$${Number(investedUsd || 0).toLocaleString('en-US', {minimumFractionDigits: 2})}`;

                // Uninvested: preferir invested.uninvestedUsd, luego portfolio.balance, finalmente derive como displayValue - investedUsd
                let uninvestedValue = null;
                if (invested && typeof invested.uninvestedUsd === 'number' && !isNaN(invested.uninvestedUsd)) {
                    uninvestedValue = invested.uninvestedUsd;
                } else if (typeof portfolio.balance === 'number' && !isNaN(portfolio.balance)) {
                    uninvestedValue = portfolio.balance;
                } else if (typeof portfolioSummary.unrealizedPnL === 'number' && typeof portfolioSummary.realizedPnL === 'number' && typeof portfolioSummary.initialBalance === 'number') {
                    // Try to compute an approximate 'cash' as initialBalance + realizedPnL - investedUsd (best-effort)
                    uninvestedValue = Math.max(0, (portfolioSummary.initialBalance + portfolioSummary.realizedPnL) - investedUsd);
                } else {
                    uninvestedValue = Math.max(0, displayValue - investedUsd);
                }

                if (uninvestedTotalEl) uninvestedTotalEl.textContent = `$${Number(uninvestedValue || 0).toLocaleString('en-US', {minimumFractionDigits: 2})}`;

                // Rendimiento: preferir portfolioSummary.pnl y portfolioSummary.initialBalance
                let totalReturn = null;
                if (typeof portfolioSummary.pnl === 'number' && typeof portfolioSummary.initialBalance === 'number' && portfolioSummary.initialBalance !== 0) {
                    totalReturn = (portfolioSummary.pnl / portfolioSummary.initialBalance) * 100;
                } else if (typeof portfolio.totalReturn === 'number') {
                    totalReturn = portfolio.totalReturn;
                } else {
                    // Fallback: compute from displayValue assuming initial 10k
                    const initial = (typeof portfolioSummary.initialBalance === 'number') ? portfolioSummary.initialBalance : 10000;
                    totalReturn = ((displayValue - initial) / initial) * 100;
                }

                const returnElement = document.getElementById('totalReturn');
                if (returnElement) {
                    const rt = Number(totalReturn || 0);
                    returnElement.textContent = `${rt.toFixed(2)}%`;
                    returnElement.className = `metric-value ${rt >= 0 ? 'positive' : 'negative'}`;
                }

                // Actualizar barra de progreso
                const returnProgressEl = document.getElementById('returnProgress');
                if (returnProgressEl) {
                    const progress = Math.max(0, Math.min(100, 50 + (Number(totalReturn || 0) * 2)));
                    returnProgressEl.style.width = `${progress}%`;
                }
            }

            updateMarket() {
                const market = this.data.market || {};
                
                const btcPriceEl = document.getElementById('btcPrice');
                if (btcPriceEl) {
                    btcPriceEl.textContent = 
                        `$${(market.price || 0).toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                }
                
                const change24h = market.change24h || 0;
                const changeElement = document.getElementById('priceChange');
                if (changeElement) {
                    changeElement.textContent = `${change24h.toFixed(2)}%`;
                    changeElement.className = `metric-value ${change24h >= 0 ? 'positive' : 'negative'}`;
                }
                
                const lastUpdateEl = document.getElementById('lastUpdate');
                if (lastUpdateEl) {
                    lastUpdateEl.textContent = 
                        market.timestamp ? new Date(market.timestamp).toLocaleTimeString() : '-';
                }
            }

            updateBot() {
                const bot = this.data.bot || {};
                
                // Estado del bot
                const statusElement = document.getElementById('botStatus');
                if (statusElement) {
                    statusElement.textContent = bot.isActive ? 'Activo' : 'Inactivo';
                    statusElement.className = `status-badge ${bot.isActive ? 'status-active' : 'status-inactive'}`;
                }
                
                // Actualizar botones seg√∫n el estado
                this.updateControlButtons(bot.isActive);
                
                // Actualizar estrategia en la interfaz
                if (bot.strategy) {
                    document.querySelectorAll('.strategy-option').forEach(option => {
                        option.classList.remove('active');
                    });
                    const activeOption = document.querySelector(`[data-strategy="${bot.strategy}"]`);
                    if (activeOption) {
                        activeOption.classList.add('active');
                    }
                }
                
                // An√°lisis de IA
                const signals = bot.signals || {};
                console.log('üìä updateBot -> signals:', signals);
                const currentSignalEl = document.getElementById('currentSignal');
                if (currentSignalEl) {
                    currentSignalEl.textContent = signals.signal || 'HOLD';
                }
                const confidenceEl = document.getElementById('confidence');
                if (confidenceEl) {
                    confidenceEl.textContent = `${signals.confidence || 0}%`;
                }
                
                const indicators = signals.indicators || {};
                console.log('üìä updateBot -> indicators:', indicators);
                console.log('üìä updateBot -> stoch:', indicators.stoch);
                document.getElementById('rsiValue').textContent = 
                    indicators.rsi ? indicators.rsi.toFixed(1) : '-';
                
                document.getElementById('smaValues').textContent = 
                    indicators.sma20 && indicators.sma50 ? 
                    `${indicators.sma20.toFixed(0)} / ${indicators.sma50.toFixed(0)}` : '- / -';

                // Actualizar valores de estoc√°stico
                const stoch = indicators.stoch || {};
                
                const formatStochValue = (stochData) => {
                    if (!stochData || typeof stochData.k === 'undefined' || typeof stochData.d === 'undefined') {
                        return 'Cargando...';
                    }
                    return stochData.k.toFixed(1) + ' / ' + stochData.d.toFixed(1);
                };
                
                document.getElementById('stoch15mValue').textContent = formatStochValue(stoch['15m']);
                document.getElementById('stoch30mValue').textContent = formatStochValue(stoch['30m']);
                document.getElementById('stoch1hValue').textContent = formatStochValue(stoch['60m']);
            }

            updateStats() {
                const bot = this.data.bot || {};
                const portfolioStats = this.data.stats || {};

                // Calcular total de operaciones preferentemente desde portfolioStats; si parece
                // incorrecto, recomponerlo a partir del array de trades (conteo de cierres √∫nicos).
                const rawTotalFromStats = (bot.totalTrades ?? portfolioStats.totalTrades ?? portfolioStats.total_trades);

                const computeOperationsFromTrades = (tradesArray) => {
                    if (!Array.isArray(tradesArray)) return 0;
                    // Contar cierres con position_id distintos y cierres standalone
                    const closed = tradesArray.filter(t => (t.action || '').toLowerCase() === 'close');
                    const withPos = new Set();
                    let standalone = 0;
                    for (const c of closed) {
                        const pid = c.position_id || c.positionId || null;
                        if (pid) withPos.add(pid);
                        else standalone += 1;
                    }
                    return withPos.size + standalone;
                };

                const computedTotalFromTrades = computeOperationsFromTrades(this.data.trades || []);
                let totalTrades = (typeof rawTotalFromStats === 'number' && rawTotalFromStats >= 0) ? rawTotalFromStats : computedTotalFromTrades;
                // Si el valor reportado por stats difiere del c√°lculo a partir de trades, preferimos el c√°lculo local
                if (computedTotalFromTrades > 0 && computedTotalFromTrades !== rawTotalFromStats) {
                    totalTrades = computedTotalFromTrades;
                }

                // Prefer portfolio-level stats (stats) but accept fields under bot for backward compatibility
                const rawWinningTrades = (typeof bot.winningTrades !== 'undefined' ? bot.winningTrades : (typeof portfolioStats.winningTrades !== 'undefined' ? portfolioStats.winningTrades : (portfolioStats.winning_trades || null)));
                const rawGrossWins = (typeof bot.grossWins !== 'undefined') ? bot.grossWins : (typeof portfolioStats.grossWins !== 'undefined' ? portfolioStats.grossWins : (portfolioStats.gross_wins || null));
                const rawGrossLosses = (typeof bot.grossLosses !== 'undefined') ? bot.grossLosses : (typeof portfolioStats.grossLosses !== 'undefined' ? portfolioStats.grossLosses : (portfolioStats.gross_losses || null));
                const rawWinRate = (typeof bot.winRate !== 'undefined') ? bot.winRate : (typeof portfolioStats.winRate !== 'undefined' ? portfolioStats.winRate : (portfolioStats.win_rate || null));

                // Calcular m√©tricas desde trades como fallback/validaci√≥n
                const computeStatsFromTrades = (tradesArray) => {
                    const result = { winning: 0, losing: 0, grossWins: 0, grossLosses: 0 };
                    if (!Array.isArray(tradesArray) || tradesArray.length === 0) return result;

                    // Aggregate closes by position_id when available to avoid double-counting
                    const closes = tradesArray.filter(t => (t.action || '').toLowerCase() === 'close');
                    const byPos = new Map();
                    let standaloneGrossWins = 0, standaloneGrossLosses = 0, standaloneWins = 0, standaloneLosses = 0;

                    for (const c of closes) {
                        let gl = null;
                        if (typeof c.gain_loss === 'number') gl = c.gain_loss;
                        else if (typeof c.gainLoss === 'number') gl = c.gainLoss;
                        else if (typeof c.exit_price !== 'undefined' && typeof c.entry_price !== 'undefined') {
                            const amt = Number(c.amount) || 0;
                            const diff = (Number(c.exit_price) - Number(c.entry_price));
                            // For short positions, profit is entry - exit per unit
                            gl = (c.position_side === 'short' ? -diff : diff) * amt * (c.position_side === 'short' ? 1 : 1); // keep sign consistent
                        }

                        const pid = c.position_id || c.positionId || null;
                        if (pid) {
                            const prev = byPos.get(pid) || 0;
                            byPos.set(pid, prev + (typeof gl === 'number' ? gl : 0));
                        } else {
                            // Standalone close: count directly
                            if (typeof gl === 'number') {
                                if (gl > 0) { standaloneWins += 1; standaloneGrossWins += gl; }
                                else if (gl < 0) { standaloneLosses += 1; standaloneGrossLosses += Math.abs(gl); }
                            }
                        }
                    }

                    // Now evaluate positions aggregated
                    for (const [pid, totalGain] of byPos.entries()) {
                        if (typeof totalGain === 'number') {
                            if (totalGain > 0) { result.winning += 1; result.grossWins += totalGain; }
                            else if (totalGain < 0) { result.losing += 1; result.grossLosses += Math.abs(totalGain); }
                        }
                    }

                    // Add standalone counts
                    result.winning += standaloneWins;
                    result.losing += standaloneLosses;
                    result.grossWins += standaloneGrossWins;
                    result.grossLosses += standaloneGrossLosses;

                    return result;
                };

                const computedStats = computeStatsFromTrades(this.data.trades || []);

                const displayWinning = (typeof rawWinningTrades === 'number' && rawWinningTrades >= 0) ? rawWinningTrades : computedStats.winning;
                const displayGrossWins = (typeof rawGrossWins === 'number' && rawGrossWins >= 0) ? rawGrossWins : computedStats.grossWins;
                const displayGrossLosses = (typeof rawGrossLosses === 'number' && rawGrossLosses >= 0) ? rawGrossLosses : computedStats.grossLosses;
                const displayWinRate = (typeof rawWinRate === 'number' && rawWinRate >= 0) ? Number(rawWinRate) : (totalTrades > 0 ? (displayWinning / totalTrades) * 100 : 0);

                const maxDrawdown = portfolioStats.maxDrawdown ?? portfolioStats.max_drawdown ?? 0;

                const totalTradesEl = document.getElementById('totalTrades');
                const winningTradesEl = document.getElementById('winningTrades');
                const winRateEl = document.getElementById('winRate');
                const maxDrawdownEl = document.getElementById('maxDrawdown');
                const grossWinsEl = document.getElementById('grossWins');
                const grossLossesEl = document.getElementById('grossLosses');
                const profitFactorEl = document.getElementById('profitFactor');

                if (totalTradesEl) totalTradesEl.textContent = totalTrades;
                if (winningTradesEl) winningTradesEl.textContent = displayWinning;
                if (winRateEl) winRateEl.textContent = `${Number(displayWinRate || 0).toFixed(2)}%`;
                if (maxDrawdownEl) maxDrawdownEl.textContent = `${Number(maxDrawdown || 0).toFixed(2)}%`;
                // Mostrar ganancias/p√©rdidas brutas y profit factor si est√°n disponibles
                const profitFactor = (typeof bot.profitFactor !== 'undefined') ? bot.profitFactor : (typeof portfolioStats.profitFactor !== 'undefined' ? portfolioStats.profitFactor : (portfolioStats.profit_factor || null));

                if (grossWinsEl) grossWinsEl.textContent = `$${Number(displayGrossWins || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                if (grossLossesEl) grossLossesEl.textContent = `$${Number(displayGrossLosses || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                if (profitFactorEl) profitFactorEl.textContent = (profitFactor === null || typeof profitFactor === 'undefined') ? '-' : Number(profitFactor).toFixed(2);
                
            }

            updateTrades() {
                const trades = this.data.trades || [];
                const tableBody = document.getElementById('tradesTable');
                if (!tableBody) return;

                if (trades.length === 0) {
                    tableBody.innerHTML = `
                        <tr>
                            <td colspan="10" style="text-align: center; color: rgba(255,255,255,0.5);">
                                No hay operaciones a√∫n
                            </td>
                        </tr>
                    `;
                    return;
                }

                // Agrupar trades en operaciones completas (apertura + cierre).
                // Para cada trade de tipo 'close' intentamos emparejar con su position_id o related_trade_id.
                const ops = [];
                const tradesById = {};
                for (const t of trades) {
                    tradesById[t.trade_id || t.id || t.id] = t;
                }

                // Recorremos trades en orden cronol√≥gico inverso para mostrar las operaciones m√°s recientes
                for (const t of trades) {
                    const action = (t.action || '').toLowerCase();
                    if (action === 'close') {
                        // Intentar emparejar con open mediante position_id
                        const posId = t.position_id || t.positionId || null;
                        let openTrade = null;
                        if (posId) {
                            // Buscar el open correspondiente
                            openTrade = trades.find(x => (x.position_id === posId || x.positionId === posId) && (x.action || '').toLowerCase() === 'open');
                        }

                        // Si no se encuentra open por position_id, buscar por related_trade_id
                        if (!openTrade && (t.related_trade_id || t.relatedTradeId)) {
                            const rel = t.related_trade_id || t.relatedTradeId;
                            openTrade = trades.find(x => (x.trade_id === rel || x.id === rel || x.tradeId === rel) && (x.action || '').toLowerCase() === 'open');
                        }

                        // Construir operaci√≥n combinada
                        const entryPrice = openTrade ? (openTrade.entry_price || openTrade.price || 0) : (t.entry_price || t.price || 0);
                        const exitPrice = t.exit_price || t.price || 0;
                        const side = (t.position_side || (openTrade && (openTrade.position_side || openTrade.positionSide)) || (t.type === 'BUY' ? 'long' : (t.type === 'SELL' ? 'short' : '')));
                        const amount = t.amount || (openTrade ? openTrade.amount : 0);
                        const usdAmount = t.usd_amount || t.usdAmount || (openTrade ? (openTrade.usd_amount || openTrade.usdAmount || 0) : 0);
                        const gainLoss = (typeof t.gain_loss === 'number' ? t.gain_loss : (typeof t.gainLoss === 'number' ? t.gainLoss : 0));
                        const roi = t.roi || t.roi === 0 ? t.roi : (t.roi || 0);
                        const reason = (openTrade && Array.isArray(openTrade.reasons) ? openTrade.reasons[0] : (t.reasons && Array.isArray(t.reasons) ? t.reasons[0] : (t.reasons || 'N/A')));

                        ops.push({
                            openTimestamp: openTrade ? openTrade.timestamp : null,
                            closeTimestamp: t.timestamp,
                            type: t.type,
                            side: side,
                            amount: amount,
                            entryPrice: entryPrice,
                            exitPrice: exitPrice,
                            usdAmount: usdAmount,
                            gainLoss: gainLoss,
                            roi: roi,
                            reason: reason
                        });
                    }
                }

                // Ordenar por timestamp descendente y tomar los m√°s recientes
                ops.sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp));
                const recentOps = ops.slice(0, 10);

                if (recentOps.length === 0) {
                    tableBody.innerHTML = `
                        <tr>
                            <td colspan="10" style="text-align: center; color: rgba(255,255,255,0.5);">
                                No hay operaciones cerradas a√∫n
                            </td>
                        </tr>
                    `;
                    return;
                }

                tableBody.innerHTML = recentOps.map(op => {
                    const openTime = op.openTimestamp ? new Date(op.openTimestamp).toLocaleString() : '-';
                    const closeTime = op.closeTimestamp ? new Date(op.closeTimestamp).toLocaleString() : '-';
                    const gainLossClass = op.gainLoss > 0 ? 'positive' : (op.gainLoss < 0 ? 'negative' : '');
                    const roiClass = op.roi > 0 ? 'positive' : (op.roi < 0 ? 'negative' : '');
                    const sideLabel = op.side ? (op.side === 'short' ? 'SHORT' : 'LONG') : '-';
                    return `
                        <tr>
                            <td>${openTime}</td>
                            <td>${closeTime}</td>
                            <td class="trade-${op.type && op.type.toLowerCase ? op.type.toLowerCase() : ''}">${op.type}</td>
                            <td>${sideLabel}</td>
                            <td>${(op.amount || 0).toFixed(8)}</td>
                            <td>$${(op.entryPrice || 0).toLocaleString()}</td>
                            <td>$${(op.exitPrice && op.exitPrice !== op.entryPrice ? op.exitPrice.toLocaleString() : '-')}</td>
                            <td>$${Number(op.usdAmount || 0).toFixed(2)}</td>
                            <td class="${gainLossClass}">$${Number(op.gainLoss || 0).toFixed(2)}</td>
                            <td class="${roiClass}">${Number(op.roi || 0).toFixed(2)}%</td>
                            <td class="trade-reason">${(op.reason || 'N/A').toString().substring(0,25)}${(op.reason || '').toString().length > 25 ? '...' : ''}</td>
                        </tr>
                    `;
                }).join('');
            }

            addTradeToHistory(trade) {
                if (!this.data.trades) this.data.trades = [];
                this.data.trades.push(trade);
                this.updateTrades();
            }

            updatePositions() {
                const positionsData = this.data.positions || {};
                let open = positionsData.open || [];
                const market = this.data.market || {};
                const currentPrice = market.price || 0;
                const tableBody = document.getElementById('positionsTable');

                if (!tableBody) return;

                // Filter out extremely small exposures (e.g. $0.76 test trades) so the UI
                // does not show negligible positions as "open". This avoids showing
                // historical micro-trades as active positions when the canonical
                // `positions.open` may include transient entries.
                const MIN_DISPLAY_USD = 1.0;
                open = (open || []).filter(p => {
                    const entryUsd = (typeof p.entryUsd === 'number' && !isNaN(p.entryUsd)) ? Number(p.entryUsd) : null;
                    const amount = Number(p.amountBtc || p.amount || 0) || 0;
                    const notional = entryUsd !== null ? entryUsd : (amount * currentPrice);
                    return (typeof notional === 'number' && notional >= MIN_DISPLAY_USD);
                });

                // Compute a stable hash of the open positions (we only need identity, not full content)
                try {
                    const ids = (open || []).map(p => p.position_id || p.id || p.positionId || (p.side + '|' + (p.timestamp || '')));
                    ids.sort();
                    // Include currentPrice in hash so we still re-render when market price changes
                    const newHash = JSON.stringify({ ids: ids, price: currentPrice });

                    // If we have no previous hash, render immediately and store it
                    if (this._lastOpenPositionsHash === null) {
                        this._lastOpenPositionsHash = newHash;
                        // fallthrough to render now
                    } else if (this._lastOpenPositionsHash === newHash) {
                        // no change in positions identity -> skip re-render
                        return;
                    }

                    // Debounce rapid changes to avoid flicker: schedule an update after a short delay.
                    if (this._positionsUpdateTimer) clearTimeout(this._positionsUpdateTimer);
                    this._positionsUpdateTimer = setTimeout(() => {
                        // If now there is still content, render; otherwise show empty message
                        if (!open || open.length === 0) {
                            tableBody.innerHTML = `
                                <tr>
                                    <td colspan="7" style="text-align: center; color: rgba(255,255,255,0.5);">
                                        Sin posiciones abiertas
                                    </td>
                                </tr>
                            `;
                            this._lastOpenPositionsHash = JSON.stringify([]);
                            return;
                        }

                        const rows = open.map(pos => {
                            const side = pos.side === 'short' ? 'SHORT' : 'LONG';
                            const amount = pos.amountBtc || 0;
                            const entry = pos.entryPrice || 0;
                            const notional = amount * currentPrice;
                            const pnl = pos.side === 'short' ? (entry - currentPrice) * amount : (currentPrice - entry) * amount;
                            const roi = entry > 0 ? (pos.side === 'short' ? ((entry - currentPrice) / entry) * 100 : ((currentPrice - entry) / entry) * 100) : 0;
                            const pnlClass = pnl > 0 ? 'positive' : (pnl < 0 ? 'negative' : '');
                            const roiClass = roi > 0 ? 'positive' : (roi < 0 ? 'negative' : '');
                            return `
                                <tr>
                                    <td>${new Date(pos.timestamp).toLocaleString()}</td>
                                    <td>${side}</td>
                                    <td>${amount.toFixed(8)}</td>
                                    <td>$${entry.toLocaleString()}</td>
                                    <td>$${currentPrice.toLocaleString()}</td>
                                    <td>$${notional.toFixed(2)}</td>
                                    <td class="${pnlClass}">$${pnl.toFixed(2)}</td>
                                    <td class="${roiClass}">${roi.toFixed(2)}%</td>
                                </tr>
                            `;
                        }).join('');

                        tableBody.innerHTML = rows;
                        this._lastOpenPositionsHash = newHash;
                        this._positionsUpdateTimer = null;
                    }, this._positionsDebounceMs);
                } catch (err) {
                    console.error('Error in updatePositions debounce logic:', err);
                    // Fallback: render immediately to avoid blocking UI
                    const rows = (open || []).map(pos => {
                        const side = pos.side === 'short' ? 'SHORT' : 'LONG';
                        const amount = pos.amountBtc || 0;
                        const entry = pos.entryPrice || 0;
                        const notional = amount * currentPrice;
                        const pnl = pos.side === 'short' ? (entry - currentPrice) * amount : (currentPrice - entry) * amount;
                        const roi = entry > 0 ? (pos.side === 'short' ? ((entry - currentPrice) / entry) * 100 : ((currentPrice - entry) / entry) * 100) : 0;
                        const pnlClass = pnl > 0 ? 'positive' : (pnl < 0 ? 'negative' : '');
                        const roiClass = roi > 0 ? 'positive' : (roi < 0 ? 'negative' : '');
                        return `
                            <tr>
                                <td>${new Date(pos.timestamp).toLocaleString()}</td>
                                <td>${side}</td>
                                <td>${amount.toFixed(8)}</td>
                                <td>$${entry.toLocaleString()}</td>
                                <td>$${currentPrice.toLocaleString()}</td>
                                <td>$${notional.toFixed(2)}</td>
                                <td class="${pnlClass}">$${pnl.toFixed(2)}</td>
                                <td class="${roiClass}">${roi.toFixed(2)}%</td>
                            </tr>
                        `;
                    }).join('');
                    tableBody.innerHTML = rows;
                }
            }

            updatePositionsHistory() {
                const positions = this.data.positionsHistory || [];
                const tableBody = document.getElementById('positionsHistoryTable');
                if (!tableBody) return;

                if (!positions || positions.length === 0) {
                    tableBody.innerHTML = `
                        <tr>
                            <td colspan="7" style="text-align: center; color: rgba(255,255,255,0.5);">No hay historial de posiciones</td>
                        </tr>
                    `;
                    return;
                }

                // Sort by openTimestamp desc
                const ordered = positions.slice().sort((a,b) => {
                    const da = a.openTimestamp ? new Date(a.openTimestamp) : new Date(0);
                    const db = b.openTimestamp ? new Date(b.openTimestamp) : new Date(0);
                    return db - da;
                });

                const rows = ordered.map(p => {
                    const openTs = p.openTimestamp ? new Date(p.openTimestamp).toLocaleString() : '-';
                    const closeTs = p.closeTimestamp ? new Date(p.closeTimestamp).toLocaleString() : '-';
                    const entryUsd = p.entryUsd != null ? Number(p.entryUsd).toFixed(2) : '-';
                    const exitUsd = p.exitUsd != null ? Number(p.exitUsd).toFixed(2) : '-';
                    const pnl = (p.pnl != null) ? Number(p.pnl).toFixed(2) : '-';
                    const side = p.positionSide ? (p.positionSide === 'short' ? 'SHORT' : 'LONG') : '-';
                    return `
                        <tr>
                            <td>${p.positionId}</td>
                            <td>${side}</td>
                            <td>${openTs}</td>
                            <td>${closeTs}</td>
                            <td>$${entryUsd}</td>
                            <td>$${exitUsd}</td>
                            <td>$${pnl}</td>
                        </tr>
                    `;
                }).join('');

                tableBody.innerHTML = rows;
            }

            addLogEntry(message, level = 'info', originalTimestamp = null) {
                const logContainer = document.getElementById('activityLog');
                
                if (!logContainer) return;
                
                // Usar timestamp original si se proporciona, sino usar hora actual
                let timestamp;
                if (originalTimestamp) {
                    // Normalizar timestamps de SQLite ('YYYY-MM-DD HH:MM:SS' en UTC)
                    let dateObj;
                    if (typeof originalTimestamp === 'string' && originalTimestamp.includes(' ') && !originalTimestamp.includes('T')) {
                        dateObj = new Date(originalTimestamp.replace(' ', 'T') + 'Z');
                    } else {
                        dateObj = new Date(originalTimestamp);
                    }
                    timestamp = 'üìÖ ' + dateObj.toLocaleDateString() + ' ' + dateObj.toLocaleTimeString();
                } else {
                    timestamp = new Date().toLocaleTimeString();
                }
                
                // Remover mensaje de loading si existe
                const loadingElement = logContainer.querySelector('.loading');
                if (loadingElement) {
                    loadingElement.remove();
                }
                
                const entry = document.createElement('div');
                entry.className = `log-entry log-${level}`;
                
                // Agregar clase para logs hist√≥ricos
                if (originalTimestamp) {
                    entry.classList.add('log-historical');
                }
                
                // Icono seg√∫n el nivel
                const icons = {
                    'info': '‚ÑπÔ∏è',
                    'success': '‚úÖ',
                    'warning': '‚ö†Ô∏è',
                    'error': '‚ùå',
                    'trade': 'üíπ'
                };
                
                entry.innerHTML = `
                    <span class="log-timestamp">[${timestamp}]</span>
                    <span class="log-icon">${icons[level] || '‚ÑπÔ∏è'}</span>
                    <span class="log-message">${message}</span>
                `;
                
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Mantener solo las √∫ltimas 100 entradas (m√°s en el log expandido)
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }

            showAlert(message, type = 'info') {
                const alertsContainer = document.getElementById('alerts');
                
                const alert = document.createElement('div');
                alert.className = `alert alert-${type}`;
                alert.textContent = message;
                
                alertsContainer.appendChild(alert);
                
                // Remover despu√©s de 5 segundos
                setTimeout(() => {
                    if (alert.parentNode) {
                        alert.parentNode.removeChild(alert);
                    }
                }, 5000);
            }

            startPeriodicUpdates() {
                // Actualizar cada 5 segundos SIEMPRE (como fallback y para asegurar actualizaciones)
                setInterval(() => {
                    console.log('‚è∞ Periodic update triggered');
                    this.fetchData();
                }, 5000);
                
                // Primera actualizaci√≥n con delay para asegurar que el backend est√© listo
                setTimeout(() => {
                    console.log('üöÄ Initial fetchData call');
                    this.fetchData();
                }, 1000);
            }
        }

        // üåô Sistema de cambio de tema
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            const themeButton = document.getElementById('themeToggle');
            themeButton.textContent = newTheme === 'light' ? 'üåô Modo Oscuro' : '‚òÄÔ∏è Modo Claro';
        }

        // üóëÔ∏è Limpiar log de actividad
        function clearActivityLog() {
            const logContainer = document.getElementById('activityLog');
            logContainer.innerHTML = `
                <div style="text-align: center; color: var(--text-muted); padding: 20px;">
                    üìù Log limpiado - Esperando nueva actividad...
                </div>
            `;
        }

        // üé® Cargar tema guardado
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            
            const themeButton = document.getElementById('themeToggle');
            if (themeButton) {
                themeButton.textContent = savedTheme === 'light' ? 'üåô Modo Oscuro' : '‚òÄÔ∏è Modo Claro';
                themeButton.addEventListener('click', toggleTheme);
            }
        }

        // Funci√≥n para expandir/contraer la secci√≥n educativa
        function toggleInfoSection() {
            const content = document.getElementById('info-content');
            const arrow = document.getElementById('info-arrow');
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                arrow.textContent = '‚ñº';
                content.style.display = 'none';
            } else {
                content.style.display = 'block';
                setTimeout(() => {
                    content.classList.add('active');
                    arrow.textContent = '‚ñ≤';
                }, 10);
            }
        }

        // Helper: ensure core UI elements are visible and log their presence
        function ensureUiElementsVisible() {
            const ids = ['startBot','stopBot','resetBot','forceSyncBtn','stopLossInput','setStopLossBtn','stochSelector','setStochBtn'];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    try {
                        el.style.display = el.style.display || 'inline-block';
                        el.style.visibility = 'visible';
                        el.style.opacity = '1';
                        el.style.position = el.style.position || 'relative';
                        el.style.zIndex = '999';
                        console.log('UI check: element present and forced visible ->', id);
                    } catch (e) {
                        console.warn('UI check: could not modify element', id, e);
                    }
                } else {
                    console.warn('UI check: element MISSING ->', id);
                }
            });
        }

        // Inicializar dashboard cuando la p√°gina se carga
        document.addEventListener('DOMContentLoaded', () => {
            loadSavedTheme();
            // First pass: ensure elements exist in DOM and are visible
            try { ensureUiElementsVisible(); } catch(e) { console.warn('ensureUiElementsVisible failed', e); }
            window.dashboard = new TradingDashboard();
            // Second pass after a short delay in case other scripts modify the DOM
            setTimeout(() => {
                try { ensureUiElementsVisible(); } catch(e) { console.warn('ensureUiElementsVisible delayed failed', e); }
            }, 1200);
        });
    </script>
</body>
</html>